http://blog.csdn.net/iter_zc/article/details/44195731

关于页缓存，感觉这篇文章讲得比较清楚。　

这里考虑页缓存的组织方式，

详细内容在下面，不过对于我们有用的是，简单地理解，页buffer的地址一般是 host, backing_dev_info，前者是一个inode结构，代表了文件所有者，可能是文件
或者块设备，　





缓存技术是用于提高CPU访问外部块设备的访问速度而提供的一种技术，系统需要将最常使用的块设备数据放到主存中，以便CPU 可以直接从主存中读取数据。由此可见
，缓存的目的是为了加速对低速设备的访问，而Linux内核对所有以页为单位的操作使用统一的缓存框架，也就是页缓存。

页缓存中可能包含的数据有：1) 含有普通文件的数据页；2)含有目录的页；3)直接从块设备文件中读取的页；4)含有用户态进程数据的页；5）共享内存等特殊文件系统
页面。

页缓存的每个页面必然属于某个文件，Linux系统中使用struct address_space这个数据结构来表示页缓存对象，这个数据结构用于建立缓存数据和来源之间的
关联。如果访问了虚拟地址空间的某个地址，如果该空间不属于一个匿名对象，通过找到这个地址空间对象可以读取数据来源。在《虚拟内存系统》一章中提到，虚
拟地址空间对应的物理页可以看作是内存对象的缓存。此时内存对象可能是一个文件或者是一个外接设备。

在访问进程虚拟地址空间时，可以通过虚拟地址空间结构(struct vm_area_struct)中的vm_file字段可以找到地址空间映射的文件句柄， 文件句柄结构(file)
中的f_mapping字段代表文件对象映射的页缓存，它是一个address_space结构。address_space结构中的host字段是一个inode结构，它代表地址空间所有者（
文件或块设备）。address_space结构中的backing_dev_info字段是一个struct backing_dev_info结构，该结构是指向后备存储器结构，它包含了与地址空间
相关的 后备存储器的有关信息，后备存储器是指与地址空间相关的外部设备，做为地址空间中信息的来源，它通常是块设备。

另外，页框结构(struct page)中的mapping字段代表页框属于哪个文件结点的address_space对象。这样就建立起了地址空间结构(struct vm_area_struc
t)和页框结构(page)之间的双向关联关系。

如果page->mapping等于0，说明该页属于交换缓存(swap cache);
如果page->mapping不等于0且页标记中第0位为0，说明该页是一个匿名页，mapping字段指向的是一个struct anon_vma结构变量;
如果page->mapping 不等于0且页标记中第0位不为0，mapping字段指向的是一个struct address_space结构变量;
缺页处理流程中，如果发现页面属于一个文件对象，会调用该文件对象的缺页处理函数:

vma->vm_ops->fault(); (即调用filemap_fault()函数 )

此函数会获取地址空间address_space结构，调用其方法来获取页面：mapping->a_ops->readpage()。

内核使用了基数树来管理地址空间内所有的页，所有属于一个地址空间的页缓存使用基数树组织起来，同时，内核提供pdflush守护进程，它周期性的运行来将缓存页
刷新到磁盘中。

并不是所有的内存对象都是以页为单位进行管理的，也有很多是基于块来管理的，这种情况下使用的缓存称为块缓存。内存页的大小是固定的，而块缓存长度是可变的。
块缓存的大小通常较小，用作小型数据的传输，现在的Linux系统中，页缓存是主要的缓存手段，块缓存用得较少，主要用于文件系统处理元数据时。

块缓冲区也是基于物理页来实现的，块缓冲区头使用buffer_head结构体表示，通过slab缓存创建，放在独立的内存区，一个物理页被划分成若干单元，用于保存缓冲
数据。页与块缓冲区可以进行交互操作，页结构体(page)中有一个private字段，它指向第一个缓冲区头，每个缓冲区头的b_this_page成员指向下一个缓冲区头，
近而将该页上的所有缓冲区头关联起来。

pic11

有些块缓存是独立于页面的，比如程序访问文件系统时读取文件系统的几块数据，此时会建立一个独立的块缓存进行加速访问。此时缓冲头数据结构放入一个大小
d固定的数组中，以LUR的算法管理，即最常使用的数组项放在前面。

