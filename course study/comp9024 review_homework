Important homework 

Homework 4 Q2. 

Homework 4 Q5. The rules of mod% for positive numbers cannot be used for negative numbers directively. 

The knowledge need to be reviewed. 

Big omega notation. 

Homework 5 Q2

be aware of the height and depth of tree. 

Homework 5 Q4

Note that the question is that the descendants diff is no more than 5, not the height...

Homework 5 Q5

Do not forget to reset the visit flag of nodes. 

Homework 6 
Q1 the height of avl-tree < 2log(n) + 2, the height of splay tree is h < log(n+1)

external node is the nodes which do not store anything. 

Q6 removeExternal is to remove the external node and its parent, replace its parent by its sibling. 

So if removeExternal is called during the remove, if the deleted node's parent is root. In that case, the other child of the root would become 
the root afterwards, so it is still an AVL tree. 
Else if the parent is not root, the only AVL-tree which would become non-AVL tree is the one rooted at w (which is the parent of the parent of v)

Homework 7 

Q2 just use the recursive algorithm to scan each node

Q5 note that the first transformation of the sum equation and when n> 3, the equation i<2^(i/2) holds.  

Homework 8

Q1 do not forget to remove the duplicates. 

Q2 Using bucket sorting. 

Q3 Find the inverses in a sequence. 

use recursive method to solve this. firstly, divide the sequence into 2 parts. find the inverses in both of the parts. then find the 
inversions that happen among the two. 

note that once a merge is called, the two sub-sequences are already sorted. 

Homework 9 

Q1 The difference between map and dictionary ADT is that map does not hold elements with the same key while dic does. 

So we just add one more dimension to make the keys in map to be unique. 

Q2 Note that we can only move forward the elements whose keys are equal to the hash(k). Once we encounter with a key whose
key is differ from the hash(key), that means that key is not generated by probing but direct hashing. 

Q3 and Q4 Note that the time complexity should consider the length of the successors. 

Homework 10 

Q1. Instead of just returning the matching, we set i = i + 1, and j = f(m-1);

Q2. Generate a new text T' = T[n-m, ..., n-1] + T[0 ... m]. Run KMP algorithm on T' and P'.

Q5. a partial string is actually not a part of the string. Consequently, during the deletion, it cannot be deleted. 

Algorithm(T, s)
Input: T and string s
Output: a T without s
{
    search for s in the T
    if(s was not found){
       print 's is not found';      
       return -1;   //delete failed
    }
    
    else
    {
    	let u be the node where s is just found;
    	if(s is not equal to the whole string encoded at u or u has a child)
    	{
    		print 's is just a partial string';
    		return -1;   //delete failed. 
    	}
    	
    	v = the parent of u;
    	delete u;
    	if(v has only one child c)
    	{
    		v.string = v.string + c.string;
    	}
    	
    	return 0;   
    
	}
}

so sometimes if my own design of algorithm is very trivial, try if we can describe the algorithm in some high-level way. 

Q6. use LCS to solve this. 

Homework 11

Q1 

Algorithm BFS(G)
Input: G, v
Output: Labeling....

for all u belongs to vertices in G
	setLabel(u, UNEXPLORED);
for all e belongs to edges in G
	setLabel(e, UNEXPLORED);
for all v belongs to vertives in G
	BFS(G,v)
	

BFS(G,v)
setLabel(v, DISCOVERED)
q is a queue;
q.enqueue(v);

while(q is not empty){
	v = q.dequeue();
	for all e belongs to v's incident edges
		if(getLabel(e) == UNEXPLORED)
			w = getOpposite(e,v);
			if(w is UNEXPLORED)
				setLaebl(e, DISCOVERED);
				setLaebl(w, VISITED);
				q.enqueue(w);
}

Q2 其实求强连通分量就是把森林中的树找到

首先将所有节点都标上 unvisited，

然后对所有节点，如果这个节点没有访问过，就基于它做深度优先搜索，每个深度优先搜索的结果放在一个list里面，作为一个component

Q3　根据BFS的性质，用BFS就可以

从v触发，进行宽度优先搜索．注意记录每个节点的路径Q(w) = Q(s)+{v,w}

BFS如果出现已经访问过的边，标CROSS

Q5 首先给所有节点拓扑标号，然后，两重循环，看有没有逆着序号的边即可．

Homework 12

Q1 因为在一个图中，从一个源出发到其它节点的最短距离可以组成一个树，这个树的边就是最短路径

for each vertex u in G, we introduce a variable closet[u] that stores its adjacent vertex in the cloud. in order to construct the tree
, we modify the Dijkstra algorithm in this way: 

(1) whenever a vertex with the minimum D[u] is removed from the Q, add the edge (closest[u],u) to the tree T 

(2) if D[u] + w((u,z)) < D[z] holds, set closest[z] to u

So it becomes like this, 

DijkstraDistance(G,v)

D[v] = 0;

for all u (u!=v) belongs to G's vertices. 
	D[u] = inf;

Q is a priority queue containing all the vertices in G and the key of each element is D

Create a Tree T;

while Q is not empty
	
	z = Q.removeMin();
	add an edge (closest[z],z) into the Tree
	for all w who is adjacent to z
		if(D[w] > D[z] + w(w,z))
			D[w] = D[z] + w(w,z);
			closest[w] = z;
			
return T and the label D[u] for all vertex u .

Q4. 
1. How to calculate the centre of T. 

Q5


	